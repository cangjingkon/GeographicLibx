/*

Arbitrary precision Transverse Mercator Projection

Written by Charles Karney <charles@karney.com>
http://charles.karney.info/geographic

$Id$

The parameters for the transformation are set by

setparams(a,invf,k0)$ sets the major radius, inverse flattening, and
    central scale factor. The default is
      setparams(6378137b0, 298.257223563b0, 0.9996b0)$
    appropriate for UTM applications.

Then 3 different ways of computing Transverse Mercator are given using
different intermediate conformal transformations:

Polar stereographic: tm1(lat,lon) and ll1(x,y)
Mercator: tm2(lat,lon) and ll2(x,y) (and tm2a(lat,lon))
Spheroidal transverse Mercator: tm2(lat,lon)

In carrying out the forward transformations, the compounded derivative
is computed and used to compute the convergence and scale of the
transformation.

tm[123] take lat and lon args (in degrees) and return [x, y,
    convergence, scale].  [x, y] do not include false
    eastings/northings but do include the scale factor k0.
    convergence is in degrees.

ll[12] take x and y args (in meters) and return [lat, lon] in degrees.

Thus:

    r:tm1(10b0,20b0)$
    ll1(r[1],r[2]);

should return close to [10b0, 20b0].

The basic idea in tm1 is outlined in an Email to the Proj mailing list
from Strebe@aol.com dated Wed Oct 15 00:10:38 EDT 2003.

phic_rho (resp. phi_psi) uses Newton's method with phic0 (resp. phi0) as
an initial guess and sets nphic0 (nphi0) as the returned result.

This allows you to track a solution in case the root finding fails or
there are multiple roots.  For example the following code find two
distinct results for tm1 by going different ways around the singularity
at 0N 90*(1-e)E.

    lat0:0b0;
    lon0:82.636b0;
    del:0.1b0$
    phic0:0b0;
    for i:-10 thru 3 do (
      c:[lat0+del*sin(i/10*pi),lon0+del*cos(i/10*pi)],
      res:apply(tm1,c),
      phic0:nphic0)$
    (ca:c,resa:res)$
    phic0:0b0;
    for i:10 step -1 thru 3 do (
      c:[lat0+del*sin(i/10*pi),lon0+del*cos(i/10*pi)],
      res:apply(tm1,c),
      phic0:nphic0)$
    (cb:c,resb:res)$

[chic_muc also uses Newton's method but with the argument as the initial
guess.]

*/

load("ellint.mac")$

fpprec:120$
tol:1.b-60$

pi:bfloat(%pi)$
degree:pi/180$
ratprint:false$

setparams(a1,invf,k1):=(a:bfloat(a1),f:1/bfloat(invf),k0:bfloat(k1),
  e:sqrt(f*(2-f)),'done)$
setparams(6378137b0, 298.257223563b0, 0.9996b0)$  /* WGS 84 */
/* setparams(6378388b0, 297b0, 0.9996b0)$  International */

/*
Interpret x_y(y) as x <- y, i.e., "transform quantity y to quantity x"

Let

phi = geodetic latitude
beta = conformal latitude
psi = isometric latitude
chi = reduced latitude
mu = rectifying latitude (unnormalized)

Add "c" suffix for complement.  Note that
muc = rectifying colatitude s.t. muc*a is distance from pole along meridian
rho = radius of polar stereographic coord * c
  [c = sqrt( (1 + e)^(1 + e) * (1 - e)^(1 - e) )]

Usually add "z" prefix to denote complex

scale = dproj/ds, ds = physical distance.
*/

complement(theta):=pi/2-theta$

betac_rho(rho):=rectform(2 * atan(rho/2))$
rho_betac(betac):=rectform(2 * tan(betac/2))$
diff_betac_rho(rho):=1/( (rho/2)^2+1 )$
diff_rho_betac(betac):=rectform(sec(betac/2)^2)$

rho_phic(phic):=rectform(
  2 * tan(phic/2) *
  ((1 + e * cos(phic))/(1-e * cos(phic)))^(e/2) )$

diff_muc_phic(phic) := (1-e^2)/(1-e^2*cos(phic)^2)^(3/2)$

diff_rho_phic(phic):=rectform(
  (1-e^2)/
  ((1-e*cos(phic))^(1+e/2) * (1+e*cos(phic))^(1-e/2) * cos(phic/2)^2 ) )$

phic0:0b0$
phic_rho(z):=block([
  phic:phic0 /* betac_rho(z) */,
  dphic,v,temp],
  for i do (
    if i > 100 then error("too many iterations"),
    v:rho_phic(phic),
    temp:-rectform((v-z)/diff_rho_phic(phic)),
    if i>10 and abs(temp) > abs(dphic) then error("not converging"),
    dphic:temp,
    phic:phic+dphic,
    dphic:abs(dphic),
    /* error is approx dphic^2/2 */
    if dphic < sqrt(tol) then return(false)
    ),
  nphic0:phic
  )$

betac_phic(phic):=betac_rho(rho_phic(phic))$
phic_betac(betac):=phic_rho(rho_betac(betac))$

psi_betac(betac):=-log(tan(rectform(betac/2)))$
betac_psi(psi):=rectform(2*atan(exp(-psi)))$
diff_psi_betac(betac):=rectform(-csc(betac))$
diff_betac_psi(psi):=rectform(-sech(psi))$

beta_psi(psi):=rectform(atan(sinh(psi)))$
psi_beta(phi):=rectform(asinh(tan(phi)))$
diff_beta_psi(psi):=rectform(sech(psi))$
diff_psi_beta(phi):=rectform(sec(phi))$

/* chic_phic(phic):=atan(rectform(tan(phic)/sqrt(1-e^2)))$ */
/* phic_chic(chic):=atan(rectform(tan(chic)*sqrt(1-e^2)))$ */
/* Need to make this odd */
chic_phic(phic):=(if realpart(phic) < 0.b0 then -1 else 1)*
acos(rectform(cos(phic)*sqrt((1-e^2)/(1-e^2*cos(phic)^2))))$
phic_chic(chic):=(if realpart(chic) < 0.b0 then -1 else 1)*
acos(rectform(cos(chic)/sqrt(1-e^2*sin(chic)^2)))$

diff_phic_chic(chic):=rectform(sqrt(1-e^2)/(1-e^2*sin(chic)^2))$

atnh(x):=rectform(log((1+x)/(1-x))/2)$
psi_phi(phi):=rectform( atnh(sin(phi)) - e * atnh(e * sin(phi)) )$

diff_psi_phi(phi):=rectform(
  1/cos(phi)-e^2*cos(phi)/(1-e^2*sin(phi)^2) )$
phi0:1b0$
phi_psi(psi):=block([phi,dphi,v],
  phi:phi0,
  for i do (
    if i > 100 then error("too many iterations"),
    v:psi_phi(phi),
    dphi:-rectform((v-psi)/diff_psi_phi(phi)),
    phi:phi+dphi,
    dphi:abs(dphi),
    /* error is approx dphi^2/2 */
    if dphi < sqrt(tol) then return(false)
    ),
  nphi0:phi
  )$

muc_chic(chic):=ei(chic,e^2)$
diff_muc_chic(chic):=rectform( sqrt(rectform(1-e^2*sin(chic)^2)) )$
chic_muc(muc):=block([chic:muc,dchic,v],
  for i do (
    if i > 100 then error("too many iterations"),
    v:muc_chic(chic),
    dchic:-rectform((v-muc)/diff_muc_chic(chic)),
    chic:chic+dchic,
    dchic:abs(dchic),
    /* print(dchic), */
    /* error is approx dchic^2/2 */
    if dchic < sqrt(tol) then return(false)
    ),
  chic
  )$

/*
intermediate conformal transformation is polar stereographic

phi -> phic -> rho -> zrho -> zphic -> zchic -> zmuc -> [x,y]
               lam /
*/
tm1(phi,lam):=block([zrho,zphic,zchic,zmuc,zz,scale,phic],
  phic:(90-phi)*degree,
  lam:lam*degree,
  /* origin = 90,0 (N pole), real = long0, imag = long90 */
  zrho:rectform( rho_phic(phic)*exp(%i*lam) ),
  scale:rectform(
    diff_rho_phic(phic)/diff_muc_phic(phic)*
    exp(%i*(lam+90*degree))),
  zphic:phic_rho(zrho),
  scale:rectform(scale/diff_rho_phic(zphic)),
  zchic:chic_phic(zphic),
  scale:rectform(scale/diff_phic_chic(zchic)),
  zmuc:muc_chic(zchic),
  scale:rectform(scale*diff_muc_chic(zchic)),
  zz:rectform(-%i*zmuc + %i * ec(e^2) ),
  scale:rectform(-%i*scale),
  zz:rectform(zz*a*k0),
  [realpart(zz),imagpart(zz),bfloat(carg(scale))/degree,k0*abs(scale)])$

/* reverse steps of tm1 */

ll1(x,y):=block([zrho,zphic,zchic,zmuc,scale,phic,lam,rho],
  zmuc:rectform(%i*(x+%i*y)/(a*k0) + ec(e^2)),
  zchic:chic_muc(zmuc),
  zphic:phic_chic(zchic),
  zrho:rho_phic(zphic),
  rho:abs(zrho),
  lam:carg(zrho),
  phic:phic_rho(rho),
  [90-phic/degree,lam/degree])$

/*
intermediate conformal transformation is Mercator

phi -> psi -> zpsi -> zphi -> zphic -> zchic -> zmuc -> [x,y]
       lam /
*/

tm2(phi,lam):=block([zpsi,zphic,zchic,zmuc,zz,scale,r,zphi],
  phi:phi*degree,
  lam:lam*degree,
  scale:1/diff_muc_phic(complement(phi)),
  /* origin = 0,0, real = N, imag = W */
  zpsi:psi_phi(phi) - %i * lam,
  scale:-%i * scale*diff_psi_phi(phi),
  zphi:phi_psi(zpsi),
  scale:scale/diff_psi_phi(zphi),
  zphic:complement(zphi),
  scale:-scale,
  zchic:chic_phic(zphic),
  scale:rectform(scale/diff_phic_chic(zchic)),
  zmuc:muc_chic(zchic),
  scale:rectform(scale*diff_muc_chic(zchic)),
  zz:rectform(-%i*zmuc + %i * ec(e^2) ),
  scale:rectform(-%i*scale),
  zz:rectform(zz*a*k0),
  [realpart(zz),imagpart(zz),bfloat(carg(scale))/degree,k0*abs(scale)])$

/* reverse steps in tm2 */

ll2(x,y):=block([zmuc,zchic,zphic,zphi,lam,zpsi,phi,psi],
  zmuc:rectform(%i*(x+%i*y)/(a*k0) + ec(e^2)),
  zchic:chic_muc(zmuc),
  zphic:phic_chic(zchic),
  zphi:complement(zphic),
  zpsi:psi_phi(zphi),
  psi:realpart(zpsi),
  lam:-imagpart(zpsi),
  phi:phi_psi(psi),
  [phi/degree, lam/degree])$

/*
intermediate conformal transformation is Mercator (alternate route)

phi -> phic -> rho -> betac -> psi -> zpsi -> zbetac -> zrho -> zphic
                               lam /
                                            -> zchic -> zmuc -> [x,y]
*/

tm2a(phi,lam):=block([zpsi,zphic,zchic,zmuc,zz,scale,phic,betac,zbetac,zrho,rho],
  phic:(90-phi)*degree,
  lam:lam*degree,
  rho:rho_phic(phic),
  scale:-diff_rho_phic(phic)/diff_muc_phic(phic),
  betac:betac_rho(rho),
  scale:scale*diff_betac_rho(rho),
  /* origin = 0,0, real = N, imag = W */
  zpsi:psi_betac(betac) - %i * lam,
  scale:-%i*scale * diff_psi_betac(betac),
  zbetac:betac_psi(zpsi),
  scale:rectform(scale*diff_betac_psi(zpsi)),
  zrho:rho_betac(zbetac),
  scale:rectform(scale/diff_betac_rho(zrho)),
  zphic:phic_rho(zrho),
  scale:rectform(scale/diff_rho_phic(zphic)),
  zchic:chic_phic(zphic),
  scale:rectform(scale/diff_phic_chic(zchic)),
  zmuc:muc_chic(zchic),
  scale:rectform(scale*diff_muc_chic(zchic)),
  zz:rectform(-%i*zmuc + %i * ec(e^2) ),
  scale:rectform(-%i*scale),
  zz:rectform(zz*a*k0),
  [realpart(zz),imagpart(zz),bfloat(carg(scale))/degree,k0*abs(scale)])$
 
/*

intermediate conformal transformation is spheroidal transverse Mercator

phi -> psi -> beta -> zbeta -> zbetac -> zrho -> zphic
               lam /
                               -> zchic -> zmuc -> [x,y]
*/

tm3(phi,lam):=block([scale, psi, beta, zbeta, zbetac,
  zrho, zphic, zchic, zmuc, zz],
  phi:phi*degree,
  lam:lam*degree,
  scale:1/diff_muc_phic(complement(phi)),
  psi:psi_phi(phi),
  scale:scale*diff_psi_phi(phi),
  beta:beta_psi(psi),
  scale:scale*diff_beta_psi(psi),
  zbeta:-atnh(cos(beta)*sin(lam)),
  zbeta:asin(sin(beta)*cosh(zbeta))+%i*zbeta,
  scale:rectform(scale*(-%i)/(cos(lam)-%i*sin(beta)*sin(lam))),
  zbetac:complement(zbeta),
  scale:-scale,
  zrho:rho_betac(zbetac),
  scale:rectform(scale*diff_rho_betac(zbetac)),
  zphic:phic_rho(zrho),
  scale:rectform(scale/diff_rho_phic(zphic)),
  zchic:chic_phic(zphic),
  scale:rectform(scale/diff_phic_chic(zchic)),
  zmuc:muc_chic(zchic),
  scale:rectform(scale*diff_muc_chic(zchic)),
  zz:rectform(-%i*zmuc + %i * ec(e^2) ),
  scale:rectform(-%i*scale),
  zz:rectform(zz*a*k0),
  [realpart(zz),imagpart(zz),bfloat(carg(scale))/degree,k0*abs(scale)])$
